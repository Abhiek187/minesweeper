{"version":3,"sources":["components/Tile.tsx","components/App.tsx","components/Board.tsx","components/TopBar.tsx","reportWebVitals.ts","index.tsx"],"names":["TileState","GameState","Tile","number","state","onClick","onRightClick","type","className","onContextMenu","style","backgroundColor","Open","visibility","Hidden","Flagged","Board","gameState","isAI","boardWidth","boardHeight","mines","onInitialClick","onWin","onLose","useState","Array","map","_","prob","tiles","setTiles","excludeIndices","arr","exs","filter","i","includes","getAdjacentTiles","useCallback","tile","Math","floor","x","y","adjacentTiles","placeMines","excludedTiles","indices","from","length","keys","randI","random","shuffleArray","slice","uncoverTile","index","currentTiles","newTiles","adjacentTile","remainingTiles","generateBoard","clickedTile","push","badTiles","badTile","determineGameAction","Initial","Playing","startAgent","randTile","console","log","tileNum","adjacentFlaggedTiles","adjacentHiddenTiles","mineOdds","flaggedTiles","newTile","round","minesRemaining","minProb","safestTiles","abs","Number","EPSILON","useEffect","coveredTiles","width","height","gridTemplateColumns","gridTemplateRows","event","preventDefault","flagTile","TopBar","onReset","onStartAI","onChangeWidth","onChangeHeight","onChangeMines","timer","setTimer","timeInterval","useRef","current","setInterval","Win","Lose","undefined","clearInterval","handleInput","callback","inputElement","target","newVal","parseInt","value","min","max","isNaN","setCustomValidity","color","mins","toString","padStart","secs","timerToString","htmlFor","id","onChange","App","setGameState","setIsAI","setWidth","setHeight","setMines","newWidth","newHeight","newMines","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"4NAGYA,E,2GAAAA,O,mBAAAA,I,qBAAAA,I,gBAAAA,M,KAaZ,ICXYC,EDiCGC,EAtBoB,SAAC,GAA8C,IAA5CC,EAA2C,EAA3CA,OAAQC,EAAmC,EAAnCA,MAAOC,EAA4B,EAA5BA,QAASC,EAAmB,EAAnBA,aAE1D,OACI,wBACIC,KAAK,SACLC,UAAU,cACVH,QAASA,EACTI,cAAeH,EACfI,MAAO,CACHC,gBAAiBP,IAAUJ,EAAUY,KAAO,UAAY,WANhE,SAQI,qBAAKJ,UAAU,YAAYE,MAAO,CAC9BG,WAAYT,IAAUJ,EAAUc,QAChB,IAAXX,GAAgBC,IAAUJ,EAAUe,QAAW,SAAW,WAFnE,SAIKX,IAAUJ,EAAUe,QAAU,mBAAGP,UAAU,gBACtCL,GAAU,EAAIA,EAAS,mBAAGK,UAAU,qBE0T3CQ,EApUqB,SAAC,GAE/B,IADAC,EACD,EADCA,UAAWC,EACZ,EADYA,KAAMC,EAClB,EADkBA,WAAYC,EAC9B,EAD8BA,YAAaC,EAC3C,EAD2CA,MAAOC,EAClD,EADkDA,eAAgBC,EAClE,EADkEA,MAAOC,EACzE,EADyEA,OAW1E,EAA0BC,mBAAqB,YAAIC,MAAMP,EAAaC,IAAcO,KAAI,SAAAC,GAAC,MAAK,CAC1FzB,OAAQ,EACRC,MAAOJ,EAAUc,OACjBe,MAAO,OAHX,mBAAOC,EAAP,KAAcC,EAAd,KAMMC,EAAiB,SAACC,EAAeC,GAAhB,OACnBD,EAAIE,QAAO,SAACP,EAAGQ,GAAJ,OAAWF,EAAIG,SAASD,OAajCE,EAAmBC,uBAAY,SAACC,GAElC,MAAiC,CAACA,EAAOrB,EAAYsB,KAAKC,MAAMF,EAAOrB,IAAhEwB,EAAP,KAAUC,EAAV,KACIC,EAA0B,CAC1BL,EAAOrB,EAAa,EAAGqB,EAAOrB,EAAYqB,EAAOrB,EAAa,EAC9DqB,EAAO,EAAGA,EAAO,EACjBA,EAAOrB,EAAa,EAAGqB,EAAOrB,EAAYqB,EAAOrB,EAAa,GAkClE,OA9BU,IAANwB,EAGIE,EAAgBb,EAAea,EAFzB,IAAND,EAE8C,CAAC,EAAG,EAAG,EAAG,EAAG,GACpDA,IAAMxB,EAAc,EAEmB,CAAC,EAAG,EAAG,EAAG,EAAG,GAGb,CAAC,EAAG,EAAG,IAElDuB,IAAMxB,EAAa,EAGtB0B,EAAgBb,EAAea,EAFzB,IAAND,EAE8C,CAAC,EAAG,EAAG,EAAG,EAAG,GACpDA,IAAMxB,EAAc,EAEmB,CAAC,EAAG,EAAG,EAAG,EAAG,GAGb,CAAC,EAAG,EAAG,IAE5C,IAANwB,EAEPC,EAAgBb,EAAea,EAAe,CAAC,EAAG,EAAG,IAC9CD,IAAMxB,EAAc,IAE3ByB,EAAgBb,EAAea,EAAe,CAAC,EAAG,EAAG,KAGlDA,IACR,CAACzB,EAAaD,IAEX2B,EAAaP,uBAAY,SAACQ,GAE5B,IAAIC,EAAoBtB,MAAMuB,KAAKvB,MAAMI,EAAMoB,QAAQC,QAGvD,OADAH,EAzDiB,SAACf,GAElB,IAAK,IAAIG,EAAI,EAAGA,EAAIH,EAAIiB,OAAQd,IAAK,CACjC,IAAMgB,EAAgBX,KAAKC,MAAMD,KAAKY,SAAWpB,EAAIiB,QADpB,EAEV,CAACjB,EAAImB,GAAQnB,EAAIG,IAAvCH,EAAIG,GAF4B,KAExBH,EAAImB,GAFoB,KAKrC,OAAOnB,EAkDGqB,CADVN,EAAUhB,EAAegB,EAASD,KAEnBQ,MAAM,EAAGlC,KACzB,CAACA,EAAOS,EAAMoB,SAEXM,EAAcjB,uBAAY,SAACkB,GAA2D,IAA5CC,EAA2C,uDAAhB5B,EAGjE6B,EAAoB,YAAOD,GAGjC,GAFAC,EAASF,GAAOrD,MAAQJ,EAAUY,KAEC,IAA/B8C,EAAaD,GAAOtD,OAAc,CAElC,IAFkC,EAE5B0C,EAA0BP,EAAiBmB,GAFf,cAIPZ,GAJO,IAIlC,2BAA0C,CAAC,IAAhCe,EAA+B,QACtCD,EAASC,GAAcxD,MAAQJ,EAAUY,MALX,+BAStC,IAAoC,IAAhC8C,EAAaD,GAAOtD,OAAe,CAEnC,IAAK,IAAIiC,EAAI,EAAGA,EAAIN,EAAMoB,OAAQd,IAE1BN,EAAMM,GAAGhC,QAAUJ,EAAUY,OAA6B,IAArBkB,EAAMM,GAAGjC,SAC9CwD,EAASvB,GAAGhC,MAAQJ,EAAUY,MAItCY,QACG,CAEH,IAAMqC,EAAyBF,EAASxB,QAAO,SAAAK,GAAI,OAAIA,EAAKpC,QAAUJ,EAAUY,QAAMsC,OAElFW,IAAmBxC,GACnBE,IAIRQ,EAAS4B,KACV,CAACrB,EAAkBjB,EAAOG,EAAQD,EAAOO,IAEtCgC,EAAgBvB,uBAAY,SAACwB,GAG/B,IAAMJ,EAAoB,YAAO7B,GAE3BiB,EAA0BT,EAAiByB,GACjDhB,EAAciB,KAAKD,GACnB,IAP6D,EAOvDE,EAAqBnB,EAAWC,GAPuB,cAUvCkB,GAVuC,IAU7D,2BAAgC,CAC5BN,EAD4B,SACVxD,QAAU,GAX6B,kDAevC8D,GAfuC,IAe7D,2BAAgC,CAAC,IAAD,EAArBC,EAAqB,sBACD5B,EAAiB4B,IADhB,IAC5B,2BAAsD,CAAC,IAA5CN,EAA2C,SACX,IAAnCD,EAASC,GAAczD,QACvBwD,EAASC,GAAczD,UAHH,gCAf6B,8BAwB7DqD,EAAYO,EAAaJ,KAC1B,CAACrB,EAAkBQ,EAAYhB,EAAO0B,IAEnCW,EAAsB5B,uBAAY,SAACkB,GAErC,GAAIxC,IAAchB,EAAUmE,QAAS,CAEjC,GAAI/C,EAAQoB,KAAKC,MAAqB,GAAfZ,EAAMoB,SAAiB7B,EAAQoB,KAAKC,MAAqB,GAAfZ,EAAMoB,QAEnE,YADA1B,IAKJsC,EAAcL,GACdnC,SACOL,IAAchB,EAAUoE,SAE3BvC,EAAM2B,GAAOrD,QAAUJ,EAAUc,QACjC0C,EAAYC,KAIrB,CAACxC,EAAW6C,EAAezC,EAAOC,EAAgBE,EAAQM,EAAO0B,IAc9Dc,EAAa/B,uBAAY,WAE3B,GAAItB,IAAchB,EAAUmE,QAAS,CACjC,IAAMG,EAAmB9B,KAAKC,MAAMD,KAAKY,SAAWvB,EAAMoB,QAC1DsB,QAAQC,IAAR,gCAAqChC,KAAKC,MAAM6B,EAAWpD,GAA3D,cAA4EoD,EAAWpD,IACvFgD,EAAoBI,GAIxB,GAAItD,IAAchB,EAAUoE,QAA5B,CAMA,IAHA,IAAMV,EAAuB7B,EAAMH,KAAI,SAAAa,GAAI,kCAAUA,GAAV,IAAgBX,MAAO,OAGzDO,EAAI,EAAGA,EAAIN,EAAMoB,OAAQd,IAC9B,GAAIN,EAAMM,GAAGhC,QAAUJ,EAAUY,KAAM,CAGnC,IAAMiC,EAA0BP,EAAiBF,GAC3CsC,EAAkB5C,EAAMM,GAAGjC,OAC3BwE,EAA+B9B,EAAcV,QAC/C,SAAAsB,GAAK,OAAI3B,EAAM2B,GAAOrD,QAAUJ,EAAUe,WAC5CmC,OACI0B,EAA8B/B,EAAcV,QAC9C,SAAAsB,GAAK,OAAI3B,EAAM2B,GAAOrD,QAAUJ,EAAUc,UAC5CoC,OAEF,GAA4B,IAAxB0B,EAA2B,SAC/B,IAAMC,GACDH,EAAUC,GAAwBC,EAQvC,GAPAJ,QAAQC,IAAR,WAAgBhC,KAAKC,MAAMN,EAAIjB,GAA/B,cAAgDiB,EAAIjB,EAApD,8CACkB0B,EADlB,wCAEY6B,EAFZ,qDAGyBC,EAHzB,oDAIwBC,EAJxB,wCAKaC,IAEI,IAAbA,EAAgB,qBAEWhC,GAFX,IAEhB,2BAA0C,CAAC,IAAhCe,EAA+B,QACtC,GAAI9B,EAAM8B,GAAcxD,QAAUJ,EAAUc,OAAQ,CAChD6C,EAASC,GAAcxD,MAAQJ,EAAUe,QACzCyD,QAAQC,IAAR,2BAAgChC,KAAKC,MAAMkB,EAAezC,GAA1D,cAA2EyC,EAAezC,IAE1F,IAAM2D,EAAuBnB,EAASxB,QAClC,SAAA4C,GAAO,OAAIA,EAAQ3E,QAAUJ,EAAUe,WACzCmC,OACFsB,QAAQC,IAAR,UAAeK,EAAf,YAA+BzD,EAA/B,2BAAuDoB,KAAKuC,MAAMF,EAAezD,EAAQ,KAAzF,SAVQ,8BAehB,YADAU,EAAS4B,GAEN,GAAiB,IAAbkB,EAAgB,qBAEIhC,GAFJ,IAEvB,2BAA0C,CAAC,IAAhCe,EAA+B,QAClC9B,EAAM8B,GAAcxD,QAAUJ,EAAUc,SACxC0C,EAAYI,GACZY,QAAQC,IAAR,8BAAmChC,KAAKC,MAAMkB,EAAezC,GAA7D,cAA8EyC,EAAezC,MAL9E,8BASvB,OACG,oBAEwB0B,GAFxB,IAEH,2BAA0C,CAAC,IAAhCe,EAA+B,QAClC9B,EAAM8B,GAAcxD,QAAUJ,EAAUc,QAAU+D,EAAWlB,EAASC,GAAc/B,OACpF8B,EAASC,GAAc/B,KAAOgD,IAJnC,oCAQJ,GAAI/C,EAAMM,GAAGhC,QAAUJ,EAAUc,SAAgC,IAAtB6C,EAASvB,GAAGP,KAAa,CAEvE,IAAMiD,EAAuBhD,EAAMK,QAC/B,SAAAK,GAAI,OAAIA,EAAKpC,QAAUJ,EAAUe,WACnCmC,OACI+B,EAAyB5D,EAAQyD,EACjCjB,EAAyBF,EAASxB,QAAO,SAAAK,GAAI,OAAIA,EAAKpC,QAAUJ,EAAUY,QAAMsC,OACtFS,EAASvB,GAAGP,KAAOoD,EAAiBpB,EAQ5C,IAHA,IAAIqB,EAAkB,EAClBC,EAAwB,GAEnB/C,EAAI,EAAGA,EAAIN,EAAMoB,OAAQd,KAGJ,IAAtBuB,EAASvB,GAAGP,MACZY,KAAK2C,IAAIzB,EAASvB,GAAGP,KAAOqD,GAAWG,OAAOC,QAE9CH,EAAYnB,KAAK5B,IACY,IAAtBuB,EAASvB,GAAGP,MAAe8B,EAASvB,GAAGP,KAAOqD,IACrDA,EAAUvB,EAASvB,GAAGP,KACtBsD,EAAc,CAAC/C,IAKvBoC,QAAQC,IAAR,oBAAyBS,EAAzB,2BAAmDC,IACnD,IAAMZ,EAAmBY,EAAY1C,KAAKC,MAAMD,KAAKY,SAAW8B,EAAYjC,SAC5EM,EAAYe,GACZC,QAAQC,IAAR,8BAAmChC,KAAKC,MAAM6B,EAAWpD,GAAzD,cAA0EoD,EAAWpD,OACtF,CAACA,EAAYgD,EAAqBlD,EAAWqB,EAAkBjB,EAAOS,EAAO0B,IAmBhF,OAjBA+B,qBAAU,WACN,IAAMC,EAAuB1D,EAAMK,QAAO,SAAAK,GAAI,OAAIA,EAAKpC,QAAUJ,EAAUc,UAAQoC,OAE/EjC,IAAchB,EAAUmE,SAAWoB,IAAiBrE,EAAaC,GAEjEW,EAAS,YAAIL,MAAMP,EAAaC,IAAcO,KAAI,SAAAC,GAAC,MAAK,CACpDzB,OAAQ,EACRC,MAAOJ,EAAUc,OACjBe,MAAO,OAIXX,GACAoD,MAEL,CAACxC,EAAOb,EAAWE,EAAYC,EAAaF,EAAMoD,IAGjD,sBAAM9D,UAAU,aAAaE,MAAO,CAChC+E,MAAM,GAAD,OAAK,GAAKtE,EAAV,MACLuE,OAAO,GAAD,OAAK,GAAKtE,EAAV,MACNuE,oBAAoB,UAAD,OAAYxE,EAAZ,WACnByE,iBAAkB,2BAJtB,SAMK9D,EAAMH,KAAI,SAACa,EAAMiB,GAAP,OACP,cAAC,EAAD,CAEItD,OAAQqC,EAAKrC,OACbC,MAAOoC,EAAKpC,MACZC,QAAS,kBAAM8D,EAAoBV,IACnCnD,aAAc,SAACuF,GAAD,OArJb,SAACA,EAAyBpC,GAIvC,GAFAoC,EAAMC,iBAEF7E,IAAchB,EAAUoE,SAAWvC,EAAM2B,GAAOrD,QAAUJ,EAAUY,KAAM,CAC1E,IAAM+C,EAAoB,YAAO7B,GACjC6B,EAASF,GAAOrD,MACZuD,EAASF,GAAOrD,QAAUJ,EAAUc,OAASd,EAAUe,QAAUf,EAAUc,OAC/EiB,EAAS4B,IA6IwBoC,CAASF,EAAOpC,KAJpCA,SCrNVuC,G,MA1GuB,SAAC,GAEjC,IADA/E,EACD,EADCA,UAAWE,EACZ,EADYA,WAAYC,EACxB,EADwBA,YAAaC,EACrC,EADqCA,MAAO4E,EAC5C,EAD4CA,QAASC,EACrD,EADqDA,UAAWC,EAChE,EADgEA,cAAeC,EAC/E,EAD+EA,eAAgBC,EAC/F,EAD+FA,cAEhG,EAA0B5E,mBAAiB,GAA3C,mBAAO6E,EAAP,KAAcC,EAAd,KACMC,EAAeC,mBAErBlB,qBAAU,WACN,OAAQtE,GACJ,KAAKhB,EAAUoE,QACXmC,EAAaE,QAAUC,aAAY,WAC/BJ,GAAS,SAAAD,GAAK,OAAIA,EAAQ,OAC3B,KACH,MACJ,KAAKrG,EAAU2G,IACf,KAAK3G,EAAU4G,UACkBC,IAAzBN,EAAaE,SACbK,cAAcP,EAAaE,SAG/B,MACJ,aACiCI,IAAzBN,EAAaE,SACbK,cAAcP,EAAaE,SAG/BH,EAAS,GAIjB,OAAO,gBAC0BO,IAAzBN,EAAaE,SACbK,cAAcP,EAAaE,YAGpC,CAACzF,IAEJ,IAOM+F,EAAc,SAACnB,EAAwBoB,GAEzC,IAAMC,EAAerB,EAAMsB,OACrBC,EAAiBC,SAASH,EAAaI,OACvCC,EAAcF,SAASH,EAAaK,KACpCC,EAAcH,SAASH,EAAaM,KAGtCC,MAAML,GACNF,EAAaQ,kBAAb,6CAAqEH,EAArE,gBAAgFC,EAAhF,gBAEOJ,EAASG,GAAOH,EAASI,EAChCN,EAAaQ,kBAAb,oDAA4EH,EAA5E,gBAAuFC,EAAvF,iBAIJP,EAASG,GACTnB,MAGJ,OACI,yBAAQzF,UAAU,cAAlB,UACI,wBAAQD,KAAK,QAAQC,UAAU,eAAeH,QAAS4F,EAAvD,mBACA,wBAAQ1F,KAAK,SAASC,UAAU,YAAYH,QAAS6F,EAArD,gBACA,sBAAM1F,UAAU,QAAQE,MAAO,CAC3BiH,MAAO1G,IAAchB,EAAU2G,IAAM,QAC/B3F,IAAchB,EAAU4G,KAAO,MAAQ,SAFjD,SA/Bc,WAElB,IAAMe,EAAenF,KAAKC,MAAM4D,EAAQ,IAAIuB,WAAWC,SAAS,EAAG,KAC7DC,GAAgBzB,EAAQ,IAAIuB,WAAWC,SAAS,EAAG,KACzD,MAAM,GAAN,OAAUF,EAAV,YAAkBG,GA8BVC,KACJ,sBAAKxH,UAAU,aAAf,UACI,uBAAOyH,QAAQ,aAAf,oBACA,uBACI1H,KAAK,SACL2H,GAAG,aACHZ,MAAOnG,EACPoG,IAAI,IACJC,IAAI,KACJW,SAAU,SAAAtC,GAAK,OAAImB,EAAYnB,EAAOM,MAE1C,uBAAO8B,QAAQ,cAAf,eACA,uBACI1H,KAAK,SACL2H,GAAG,cACHZ,MAAOlG,EACPmG,IAAI,IACJC,IAAI,KACJW,SAAU,SAAAtC,GAAK,OAAImB,EAAYnB,EAAOO,SAG9C,sBAAK5F,UAAU,aAAf,UACI,uBAAOyH,QAAQ,aAAf,qBACA,uBACI1H,KAAK,SACL2H,GAAG,aACHZ,MAAOjG,EACPkG,IAAK9E,KAAKC,MAAMvB,EAAaC,EAAc,IAC3CoG,IAAK/E,KAAKC,MAAMvB,EAAaC,EAAc,IAC3C+G,SAAU,SAAAtC,GAAK,OAAImB,EAAYnB,EAAOQ,e,SF9G9CpG,O,qBAAAA,I,qBAAAA,I,aAAAA,I,gBAAAA,M,KAOZ,IAmDemI,EAnDO,WAClB,MAAkC3G,mBAAoBxB,EAAUmE,SAAhE,mBAAOnD,EAAP,KAAkBoH,EAAlB,KACA,EAAwB5G,oBAAkB,GAA1C,mBAAOP,EAAP,KAAaoH,EAAb,KACA,EAA0B7G,mBAAiB,GAA3C,mBAAOgE,EAAP,KAAc8C,EAAd,KACA,EAA4B9G,mBAAiB,GAA7C,mBAAOiE,EAAP,KAAe8C,EAAf,KACA,EAA0B/G,mBAAiBgB,KAAKC,MAAM+C,EAAQC,EAAS,KAAvE,mBAAOrE,EAAP,KAAcoH,EAAd,KASA,OACI,sBAAKjI,UAAU,MAAf,UACI,oBAAIA,UAAU,QAAd,yBACA,cAAC,EAAD,CACIS,UAAWA,EACXE,WAAYsE,EACZrE,YAAasE,EACbrE,MAAOA,EACP4E,QAAS,WACLoC,EAAapI,EAAUmE,SACvBkE,GAAQ,IAEZpC,UAAW,WAjBfjF,IAAchB,EAAUmE,SACxBkE,GAAQ,IAiBJnC,cAAe,SAAAuC,GAAQ,OAAIH,EAASG,IACpCtC,eAAgB,SAAAuC,GAAS,OAAIH,EAAUG,IACvCtC,cAAe,SAAAuC,GAAQ,OAAIH,EAASG,MAExC,cAAC,EAAD,CACI3H,UAAWA,EACXC,KAAMA,EACNC,WAAYsE,EACZrE,YAAasE,EACbrE,MAAOA,EACPC,eAAgB,kBAAM+G,EAAapI,EAAUoE,UAC7C9C,MAAO,WACH8G,EAAapI,EAAU2G,KACvB0B,GAAQ,IAEZ9G,OAAQ,WACJ6G,EAAapI,EAAU4G,MACvByB,GAAQ,UG1CbO,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACL,cAAC,IAAMC,WAAP,UACI,cAAC,EAAD,MAEJC,SAASC,eAAe,SAM5Bb,M","file":"static/js/main.591366a9.chunk.js","sourcesContent":["import React from 'react';\r\nimport '../css/Tile.css';\r\n\r\nexport enum TileState {\r\n    Hidden, // the number or mine is hidden\r\n    Flagged, // a flag is shown after a right click\r\n    Open // the number or mine is revealed\r\n}\r\n\r\ntype BoardProps = {\r\n    number: number,\r\n    state: TileState,\r\n    onClick: React.MouseEventHandler<HTMLButtonElement>,\r\n    onRightClick: React.MouseEventHandler<HTMLButtonElement>\r\n};\r\n\r\nconst Tile: React.FC<BoardProps> = ({ number, state, onClick, onRightClick }) => {\r\n    // Context Menu = Right Click\r\n    return (\r\n        <button\r\n            type=\"button\"\r\n            className=\"mine-button\"\r\n            onClick={onClick}\r\n            onContextMenu={onRightClick}\r\n            style={{\r\n                backgroundColor: state === TileState.Open ? \"#959595\" : \"#ededed\"\r\n            }}>\r\n            <div className=\"mine-tile\" style={{\r\n                visibility: state === TileState.Hidden ||\r\n                    (number === 0 && state !== TileState.Flagged) ? \"hidden\" : \"visible\"\r\n            }}>\r\n                {state === TileState.Flagged ? <i className=\"fas fa-flag\" />\r\n                    : number >= 0 ? number : <i className=\"fas fa-bomb\" />}\r\n            </div>\r\n        </button>\r\n    );\r\n};\r\n\r\nexport default Tile;\r\n","import React, { useState } from 'react';\r\nimport '../css/App.css';\r\nimport Board from './Board';\r\nimport TopBar from './TopBar';\r\n\r\nexport enum GameState {\r\n    Initial, // tiles are hidden and the timer is at 0\r\n    Playing, // timer is counting and each tile is revealed\r\n    Win, // all the safe spaces are revealed and the timer stops\r\n    Lose // a mine is clicked and the timer stops\r\n}\r\n\r\nconst App: React.FC = () => {\r\n    const [gameState, setGameState] = useState<GameState>(GameState.Initial);\r\n    const [isAI, setIsAI] = useState<boolean>(false);\r\n    const [width, setWidth] = useState<number>(9);\r\n    const [height, setHeight] = useState<number>(9);\r\n    const [mines, setMines] = useState<number>(Math.floor(width * height * 0.2));\r\n\r\n    const enableAI = (): void => {\r\n        // The AI can only be enabled on the initial game state\r\n        if (gameState === GameState.Initial) {\r\n            setIsAI(true);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <h1 className=\"title\">Minesweeper</h1>\r\n            <TopBar\r\n                gameState={gameState}\r\n                boardWidth={width}\r\n                boardHeight={height}\r\n                mines={mines}\r\n                onReset={() => {\r\n                    setGameState(GameState.Initial);\r\n                    setIsAI(false); // in case the AI is playing\r\n                }}\r\n                onStartAI={() => enableAI()}\r\n                onChangeWidth={newWidth => setWidth(newWidth)}\r\n                onChangeHeight={newHeight => setHeight(newHeight)}\r\n                onChangeMines={newMines => setMines(newMines)}\r\n            />\r\n            <Board\r\n                gameState={gameState}\r\n                isAI={isAI}\r\n                boardWidth={width}\r\n                boardHeight={height}\r\n                mines={mines}\r\n                onInitialClick={() => setGameState(GameState.Playing)}\r\n                onWin={() => {\r\n                    setGameState(GameState.Win);\r\n                    setIsAI(false);\r\n                }}\r\n                onLose={() => {\r\n                    setGameState(GameState.Lose);\r\n                    setIsAI(false);\r\n                }}\r\n            />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default App;\r\n","import React, { useCallback, useEffect, useState } from 'react';\r\nimport '../css/Board.css';\r\nimport { GameState } from './App';\r\nimport Tile, { TileState } from './Tile';\r\n\r\ntype BoardProps = {\r\n    gameState: GameState,\r\n    isAI: boolean,\r\n    boardWidth: number,\r\n    boardHeight: number,\r\n    mines: number,\r\n    onInitialClick(): void,\r\n    onWin(): void,\r\n    onLose(): void\r\n};\r\n\r\ntype MineTile = {\r\n    number: number, // number of surrounding mines\r\n    state: TileState, // whether the tile is open, closed, or flagged\r\n    prob: number // probability of a mine being present (for the agent)\r\n};\r\n\r\nconst Board: React.FC<BoardProps> = (\r\n    { gameState, isAI, boardWidth, boardHeight, mines, onInitialClick, onWin, onLose }\r\n) => {\r\n    /* Observations:\r\n     * 9x9 easy, 16x16 medium, 30x16 hard\r\n     * first tile has to be 0\r\n     * open all tiles automatically if 0\r\n     * 10% occupancy easy, 20% medium, 30% hard, 50% impossible\r\n     * select tiles w/ 0% chance of mine\r\n     * flag tiles w/ 100% chance of mine\r\n     * choose tiles w/ lowest chance of mine\r\n     */\r\n    const [tiles, setTiles] = useState<MineTile[]>([...Array(boardWidth * boardHeight)].map(_ => ({\r\n        number: 0,\r\n        state: TileState.Hidden,\r\n        prob: -1\r\n    })));\r\n\r\n    const excludeIndices = (arr: number[], exs: number[]): number[] => (\r\n        arr.filter((_, i) => !exs.includes(i))\r\n    );\r\n\r\n    const shuffleArray = (arr: number[]): number[] => {\r\n        // Swap each index with a random index\r\n        for (let i = 0; i < arr.length; i++) {\r\n            const randI: number = Math.floor(Math.random() * arr.length);\r\n            [arr[i], arr[randI]] = [arr[randI], arr[i]];\r\n        }\r\n\r\n        return arr;\r\n    };\r\n\r\n    const getAdjacentTiles = useCallback((tile: number): number[] => {\r\n        // Get the x and y position based on the index of the tile\r\n        const [x, y]: [number, number] = [tile % boardWidth, Math.floor(tile / boardWidth)];\r\n        let adjacentTiles: number[] = [\r\n            tile - boardWidth - 1, tile - boardWidth, tile - boardWidth + 1, // upper 3 [0, 1, 2]\r\n            tile - 1, tile + 1, // left and right [3, 4]\r\n            tile + boardWidth - 1, tile + boardWidth, tile + boardWidth + 1 // lower 3 [5, 6, 7]\r\n        ];\r\n\r\n        // Exclude tiles outside the board's boundaries\r\n        if (x === 0) {\r\n            if (y === 0) {\r\n                // Top left corner: only keep the 3 on the lower right\r\n                adjacentTiles = excludeIndices(adjacentTiles, [0, 1, 2, 3, 5]);\r\n            } else if (y === boardHeight - 1) {\r\n                // Bottom left corner: only keep the 3 on the upper right\r\n                adjacentTiles = excludeIndices(adjacentTiles, [0, 3, 5, 6, 7]);\r\n            } else {\r\n                // First column: ignore the left side\r\n                adjacentTiles = excludeIndices(adjacentTiles, [0, 3, 5]);\r\n            }\r\n        } else if (x === boardWidth - 1) {\r\n            if (y === 0) {\r\n                // Top right corner: only keep the 3 on the lower left\r\n                adjacentTiles = excludeIndices(adjacentTiles, [0, 1, 2, 4, 7]);\r\n            } else if (y === boardHeight - 1) {\r\n                // Bottom right corner: only keep the 3 on the upper left\r\n                adjacentTiles = excludeIndices(adjacentTiles, [2, 4, 5, 6, 7]);\r\n            } else {\r\n                // Last column: ignore the right side\r\n                adjacentTiles = excludeIndices(adjacentTiles, [2, 4, 7]);\r\n            }\r\n        } else if (y === 0) {\r\n            // First row: ignore the top\r\n            adjacentTiles = excludeIndices(adjacentTiles, [0, 1, 2]);\r\n        } else if (y === boardHeight - 1) {\r\n            // Last row: ignore the bottom\r\n            adjacentTiles = excludeIndices(adjacentTiles, [5, 6, 7]);\r\n        }\r\n\r\n        return adjacentTiles;\r\n    }, [boardHeight, boardWidth]);\r\n\r\n    const placeMines = useCallback((excludedTiles: number[]): number[] => {\r\n        // Shuffle the spaces outside the clicked area and return the indices with mines\r\n        let indices: number[] = Array.from(Array(tiles.length).keys());\r\n        indices = excludeIndices(indices, excludedTiles);\r\n        indices = shuffleArray(indices);\r\n        return indices.slice(0, mines);\r\n    }, [mines, tiles.length]);\r\n\r\n    const uncoverTile = useCallback((index: number, currentTiles: MineTile[] = tiles): void => {\r\n        // Show the selected tile\r\n        // If this is the first square clicked, currentTiles will reflect what tiles will be after re-rendering\r\n        const newTiles: MineTile[] = [...currentTiles]; // copy an array of objects\r\n        newTiles[index].state = TileState.Open;\r\n\r\n        if (currentTiles[index].number === 0) {\r\n            // Uncover all surrounding spaces if the tile's a 0\r\n            const adjacentTiles: number[] = getAdjacentTiles(index);\r\n\r\n            for (const adjacentTile of adjacentTiles) {\r\n                newTiles[adjacentTile].state = TileState.Open;\r\n            }\r\n        }\r\n\r\n        if (currentTiles[index].number === -1) {\r\n            // Lose the game if a mine is discovered\r\n            for (let i = 0; i < tiles.length; i++) {\r\n                // Show where all the other mines are located\r\n                if (tiles[i].state !== TileState.Open && tiles[i].number === -1) {\r\n                    newTiles[i].state = TileState.Open;\r\n                }\r\n            }\r\n\r\n            onLose();\r\n        } else {\r\n            // Win the game if all the covered tiles are mines\r\n            const remainingTiles: number = newTiles.filter(tile => tile.state !== TileState.Open).length;\r\n\r\n            if (remainingTiles === mines) {\r\n                onWin();\r\n            }\r\n        }\r\n\r\n        setTiles(newTiles); // refresh all the tiles\r\n    }, [getAdjacentTiles, mines, onLose, onWin, tiles]);\r\n\r\n    const generateBoard = useCallback((clickedTile: number): void => {\r\n        // Upon clicking the first tile:\r\n        // 1. Initialize the game board with 0s\r\n        const newTiles: MineTile[] = [...tiles];\r\n        // 2. Shuffle the spaces, excluding the clicked tile and its adjacent tiles\r\n        const excludedTiles: number[] = getAdjacentTiles(clickedTile);\r\n        excludedTiles.push(clickedTile);\r\n        const badTiles: number[] = placeMines(excludedTiles);\r\n\r\n        // 3. Place mines on the first x tiles, record the indices\r\n        for (const badTile of badTiles) {\r\n            newTiles[badTile].number = -1;\r\n        }\r\n\r\n        // 4. For each mine, increment the counts on all the safe adjacent spaces\r\n        for (const badTile of badTiles) {\r\n            for (const adjacentTile of getAdjacentTiles(badTile)) {\r\n                if (newTiles[adjacentTile].number !== -1) {\r\n                    newTiles[adjacentTile].number++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // 5. Uncover the selected tile + all surrounding tiles\r\n        uncoverTile(clickedTile, newTiles);\r\n    }, [getAdjacentTiles, placeMines, tiles, uncoverTile]);\r\n\r\n    const determineGameAction = useCallback((index: number): void => {\r\n        // Set the click event depending on the current game state\r\n        if (gameState === GameState.Initial) {\r\n            // Make sure the number of mines is between 10% and 30% of the board's size\r\n            if (mines < Math.floor(tiles.length * 0.1) || mines > Math.floor(tiles.length * 0.3)) {\r\n                onLose(); // force the agent to stop\r\n                return;\r\n            }\r\n\r\n            // Set up all the mines and start playing the game\r\n            generateBoard(index);\r\n            onInitialClick(); // notify the parent of a change in game state\r\n        } else if (gameState === GameState.Playing) {\r\n            // Uncover the tile and check if it's a mine (don't accidently click a flagged space)\r\n            if (tiles[index].state === TileState.Hidden) {\r\n                uncoverTile(index);\r\n            }\r\n        }\r\n        // Don't do anything if the tile is already revealed or in a game over state\r\n    }, [gameState, generateBoard, mines, onInitialClick, onLose, tiles, uncoverTile]);\r\n\r\n    const flagTile = (event: React.MouseEvent, index: number): void => {\r\n        // Don't show the right click menu\r\n        event.preventDefault();\r\n        // Toggle the flag state on an uncovered tile while playing\r\n        if (gameState === GameState.Playing && tiles[index].state !== TileState.Open) {\r\n            const newTiles: MineTile[] = [...tiles];\r\n            newTiles[index].state =\r\n                newTiles[index].state === TileState.Hidden ? TileState.Flagged : TileState.Hidden;\r\n            setTiles(newTiles);\r\n        }\r\n    };\r\n\r\n    const startAgent = useCallback((): void => {\r\n        // Start by clicking a random tile\r\n        if (gameState === GameState.Initial) {\r\n            const randTile: number = Math.floor(Math.random() * tiles.length);\r\n            console.log(`Initial: Clicking on R${Math.floor(randTile / boardWidth)}, C${randTile % boardWidth}`);\r\n            determineGameAction(randTile);\r\n        }\r\n\r\n        // Repeat until the agent wins or loses\r\n        if (gameState !== GameState.Playing) return;\r\n\r\n        // If the agent has to make a guess, generate a probability map of encountering a mine for each uncovered tile\r\n        const newTiles: MineTile[] = tiles.map(tile => ({ ...tile, prob: -1 }));\r\n\r\n        // Look at all the uncovered tiles\r\n        for (let i = 0; i < tiles.length; i++) {\r\n            if (tiles[i].state === TileState.Open) {\r\n                // Look for any situations where\r\n                // (# of the tile - # of adjacent flagged tiles)/(# of adjacent uncovered (non-flagged) tiles) = 0 or 1\r\n                const adjacentTiles: number[] = getAdjacentTiles(i);\r\n                const tileNum: number = tiles[i].number;\r\n                const adjacentFlaggedTiles: number = adjacentTiles.filter(\r\n                    index => tiles[index].state === TileState.Flagged\r\n                ).length;\r\n                const adjacentHiddenTiles: number = adjacentTiles.filter(\r\n                    index => tiles[index].state === TileState.Hidden\r\n                ).length;\r\n\r\n                if (adjacentHiddenTiles === 0) continue; // skip tiles without new information\r\n                const mineOdds: number =\r\n                    (tileNum - adjacentFlaggedTiles) / adjacentHiddenTiles;\r\n                console.log(`R${Math.floor(i / boardWidth)}, C${i % boardWidth}:\r\n                adjacentTiles = ${adjacentTiles},\r\n                tileNum = ${tileNum},\r\n                adjacentFlaggedTiles = ${adjacentFlaggedTiles},\r\n                adjacentHiddenTiles = ${adjacentHiddenTiles}\r\n                mineOdds = ${mineOdds}`);\r\n\r\n                if (mineOdds === 1) {\r\n                    // If the probability is 1, flag the adjacent tiles\r\n                    for (const adjacentTile of adjacentTiles) {\r\n                        if (tiles[adjacentTile].state === TileState.Hidden) {\r\n                            newTiles[adjacentTile].state = TileState.Flagged;\r\n                            console.log(`P = 1: Flagging R${Math.floor(adjacentTile / boardWidth)}, C${adjacentTile % boardWidth}`);\r\n                            // Calculate the amount of mines gotten\r\n                            const flaggedTiles: number = newTiles.filter(\r\n                                newTile => newTile.state === TileState.Flagged\r\n                            ).length;\r\n                            console.log(`${flaggedTiles}/${mines} mines flagged (${Math.round(flaggedTiles / mines * 100)}%)`);\r\n                        }\r\n                    }\r\n\r\n                    setTiles(newTiles);\r\n                    return;\r\n                } else if (mineOdds === 0) {\r\n                    // If the probability is 0, uncover the adjacent tiles\r\n                    for (const adjacentTile of adjacentTiles) {\r\n                        if (tiles[adjacentTile].state === TileState.Hidden) {\r\n                            uncoverTile(adjacentTile);\r\n                            console.log(`P = 0: Clicking on R${Math.floor(adjacentTile / boardWidth)}, C${adjacentTile % boardWidth}`);\r\n                        }\r\n                    }\r\n\r\n                    return;\r\n                } else {\r\n                    // Update the probability if it increases due to some other tile or is guaranteed to be safe\r\n                    for (const adjacentTile of adjacentTiles) {\r\n                        if (tiles[adjacentTile].state === TileState.Hidden && mineOdds > newTiles[adjacentTile].prob) {\r\n                            newTiles[adjacentTile].prob = mineOdds;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (tiles[i].state === TileState.Hidden && newTiles[i].prob === -1) {\r\n                // For the remaining covered tiles that aren't adjacent to an uncovered tile, set their probability as (# of mines remaining)/(# of uncovered (non-flagged) tiles)\r\n                const flaggedTiles: number = tiles.filter(\r\n                    tile => tile.state === TileState.Flagged\r\n                ).length;\r\n                const minesRemaining: number = mines - flaggedTiles;\r\n                const remainingTiles: number = newTiles.filter(tile => tile.state !== TileState.Open).length;\r\n                newTiles[i].prob = minesRemaining / remainingTiles;\r\n            }\r\n        }\r\n\r\n        // Select the tile with the smallest probability of being a mine\r\n        let minProb: number = 1;\r\n        let safestTiles: number[] = [];\r\n\r\n        for (let i = 0; i < tiles.length; i++) {\r\n            // Compare floats using epsilon\r\n            if (\r\n                newTiles[i].prob !== -1 &&\r\n                Math.abs(newTiles[i].prob - minProb) < Number.EPSILON\r\n            ) {\r\n                safestTiles.push(i);\r\n            } else if (newTiles[i].prob !== -1 && newTiles[i].prob < minProb) {\r\n                minProb = newTiles[i].prob;\r\n                safestTiles = [i];\r\n            }\r\n        }\r\n\r\n        // If there's a tie, pick a random tile\r\n        console.log(`minProb = ${minProb}, safestTiles = ${safestTiles}`);\r\n        const randTile: number = safestTiles[Math.floor(Math.random() * safestTiles.length)];\r\n        uncoverTile(randTile);\r\n        console.log(`Guess: Clicking on R${Math.floor(randTile / boardWidth)}, C${randTile % boardWidth}`);\r\n    }, [boardWidth, determineGameAction, gameState, getAdjacentTiles, mines, tiles, uncoverTile]);\r\n\r\n    useEffect(() => {\r\n        const coveredTiles: number = tiles.filter(tile => tile.state === TileState.Hidden).length;\r\n\r\n        if (gameState === GameState.Initial && coveredTiles !== boardWidth * boardHeight) {\r\n            // Initialize a new set of tiles if the size changes or the game has restarted\r\n            setTiles([...Array(boardWidth * boardHeight)].map(_ => ({\r\n                number: 0,\r\n                state: TileState.Hidden,\r\n                prob: -1\r\n            })));\r\n        }\r\n\r\n        if (isAI) {\r\n            startAgent();\r\n        }\r\n    }, [tiles, gameState, boardWidth, boardHeight, isAI, startAgent]);\r\n\r\n    return (\r\n        <main className=\"mine-board\" style={{\r\n            width: `${50 * boardWidth}px`,\r\n            height: `${50 * boardHeight}px`,\r\n            gridTemplateColumns: `repeat(${boardWidth}, 50px)`,\r\n            gridTemplateRows: \"repeat(auto-fill, 50px)\"\r\n        }}>\r\n            {tiles.map((tile, index) =>\r\n                <Tile\r\n                    key={index}\r\n                    number={tile.number}\r\n                    state={tile.state}\r\n                    onClick={() => determineGameAction(index)}\r\n                    onRightClick={(event) => flagTile(event, index)}\r\n                />\r\n            )}\r\n        </main>\r\n    );\r\n};\r\n\r\nexport default Board;\r\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport '../css/TopBar.css';\r\nimport { GameState } from './App';\r\n\r\ntype TopBarProps = {\r\n    gameState: GameState,\r\n    boardWidth: number,\r\n    boardHeight: number,\r\n    mines: number,\r\n    onReset(): void | React.MouseEventHandler,\r\n    onStartAI(): void,\r\n    onChangeWidth(newWidth: number): void,\r\n    onChangeHeight(newHeight: number): void,\r\n    onChangeMines(newMines: number): void\r\n};\r\n\r\nconst TopBar: React.FC<TopBarProps> = (\r\n    { gameState, boardWidth, boardHeight, mines, onReset, onStartAI, onChangeWidth, onChangeHeight, onChangeMines }\r\n) => {\r\n    const [timer, setTimer] = useState<number>(0);\r\n    const timeInterval = useRef<NodeJS.Timeout>();\r\n\r\n    useEffect(() => {\r\n        switch (gameState) {\r\n            case GameState.Playing:\r\n                timeInterval.current = setInterval(() => {\r\n                    setTimer(timer => timer + 1);\r\n                }, 1000);\r\n                break;\r\n            case GameState.Win:\r\n            case GameState.Lose:\r\n                if (timeInterval.current !== undefined) {\r\n                    clearInterval(timeInterval.current);\r\n                }\r\n\r\n                break;\r\n            default:\r\n                if (timeInterval.current !== undefined) {\r\n                    clearInterval(timeInterval.current);\r\n                }\r\n\r\n                setTimer(0);\r\n        }\r\n\r\n        // Clear any intervals if they're still running\r\n        return () => {\r\n            if (timeInterval.current !== undefined) {\r\n                clearInterval(timeInterval.current);\r\n            }\r\n        };\r\n    }, [gameState]);\r\n\r\n    const timerToString = (): string => {\r\n        // Add a leading zero if the number is a single digit\r\n        const mins: string = Math.floor(timer / 60).toString().padStart(2, \"0\");\r\n        const secs: string = (timer % 60).toString().padStart(2, \"0\");\r\n        return `${mins}:${secs}`;\r\n    };\r\n\r\n    const handleInput = (event: React.FormEvent, callback: (newVal: number) => void) => {\r\n        // Get the input value and call the corresponding set function from the parent\r\n        const inputElement = event.target as HTMLInputElement;\r\n        const newVal: number = parseInt(inputElement.value);\r\n        const min: number = parseInt(inputElement.min);\r\n        const max: number = parseInt(inputElement.max);\r\n\r\n        // Check to make sure the inputs are valid\r\n        if (isNaN(newVal)) {\r\n            inputElement.setCustomValidity(`Invalid number: It must be between ${min} and ${max} inclusive.`);\r\n            return;\r\n        } else if (newVal < min || newVal > max) {\r\n            inputElement.setCustomValidity(`Input is out of range: It must be between ${min} and ${max} inclusive.`);\r\n            return;\r\n        }\r\n\r\n        callback(newVal);\r\n        onReset(); // restart the game\r\n    };\r\n\r\n    return (\r\n        <header className=\"mine-header\">\r\n            <button type=\"reset\" className=\"reset-button\" onClick={onReset}>Reset</button>\r\n            <button type=\"button\" className=\"ai-button\" onClick={onStartAI}>AI</button>\r\n            <time className=\"timer\" style={{\r\n                color: gameState === GameState.Win ? \"green\"\r\n                    : gameState === GameState.Lose ? \"red\" : \"white\"\r\n            }}>{timerToString()}</time>\r\n            <div className=\"size-field\">\r\n                <label htmlFor=\"size-width\">Size: </label>\r\n                <input\r\n                    type=\"number\"\r\n                    id=\"size-width\"\r\n                    value={boardWidth}\r\n                    min=\"4\"\r\n                    max=\"16\"\r\n                    onChange={event => handleInput(event, onChangeWidth)}\r\n                />\r\n                <label htmlFor=\"size-height\">x</label>\r\n                <input\r\n                    type=\"number\"\r\n                    id=\"size-height\"\r\n                    value={boardHeight}\r\n                    min=\"4\"\r\n                    max=\"16\"\r\n                    onChange={event => handleInput(event, onChangeHeight)}\r\n                />\r\n            </div>\r\n            <div className=\"mine-field\">\r\n                <label htmlFor=\"mine-count\">Mines: </label>\r\n                <input\r\n                    type=\"number\"\r\n                    id=\"mine-count\"\r\n                    value={mines}\r\n                    min={Math.floor(boardWidth * boardHeight * 0.1)}\r\n                    max={Math.floor(boardWidth * boardHeight * 0.3)}\r\n                    onChange={event => handleInput(event, onChangeMines)}\r\n                />\r\n            </div>\r\n        </header>\r\n    );\r\n};\r\n\r\nexport default TopBar;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}